# -*- coding: utf-8 -*-
"""TIA_DESIGN.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-R8kKLvt_z0upup7pL0BhjqCdSmDry9k
"""

import numpy as np
import matplotlib.pyplot as plt

#OP-AMP SPECS

GBP = 190e+6
ADC = 10 ** (110/20)
SR = 100e+6
BW = 50e+6
Isc = 25e-6
VOmax = 0.5
#Be careful with input capacitance. If input capacitance is too big, GBP will need to be increased
CT = 1e-12 #CT is the same as CI, the total input capacitance at the inverting input of the op-amp

#Gain resistor selection
RF = VOmax / Isc
print(RF/1e+3,'kOhm')

#Minimum feedback capacitance to ensure stability
Q = 1
CFmin = (1 + np.sqrt(1 + 8 * Q **2 * np.pi * GBP * RF * CT)) / (4 * Q ** 2 * np.pi * GBP * RF)
print(np.round(CFmin/1e-12,2), "pF")
print(np.round(1 / (2 * np.pi * RF * CFmin )/1e+6,2),"MHz")
#Testing if Bandwidth can be implemented with available GBP
bw = np.arange(0,100e+6,1e+6)
gbp =  np.arange(0,1e+9,1e+6)
plt.figure()
plt.plot(bw, bw< 2 * GBP * 1/(1+np.sqrt(1 + 2 * np.pi * RF * CT * 4 * GBP)))
plt.figure()
plt.plot(gbp, BW< 2 * gbp * 1/(1+np.sqrt(1 + 2 * np.pi * RF * CT * 4 * gbp)))
print(BW < 2 * GBP * 1/(1+np.sqrt(1 + 2 * np.pi * RF * CT * 4 * GBP)))
'''
NOTICE:
You can't have a greater Bandwidth than the one calculated for the minimum feedback capacitance. Achieving stability will not be possible.
The main thing is that CFmin < CFmax. If we go above a certain fraction of the GBP, we will fail.
'''

#Maximum feedback capacitance to ensure Bandwidth preservation
CFmax = 1 / (2 * np.pi * RF * BW )
print(np.round(CFmax/1e-12,2), "pF")

#Minimum Q-factor achievable
Qmin = 1 / CFmax * np.sqrt((CT + CFmax)/(2 * np.pi * RF * GBP))
print(np.round(Qmin,2))

#Optimal feedback capacitance, for Q = 0.707; ensures Butterworth Response
Q = np.sqrt(2)/2

if(Q < Qmin):
  print("Q is too big")

CFopt = (1 + np.sqrt(1 + 8 * Q **2 * np.pi * GBP * RF * CT)) / (4 * Q ** 2 * np.pi * GBP * RF)
print(np.round(CFopt/1e-12,2), "pF")
print(np.round(1 / (2 * np.pi * RF * CFopt )/1e+6,2),"MHz")

#Full power Bandwidth: Maximum frequency for which the output is not slew rate-limited
FPBW = SR / (2 * np.pi * VOmax / 2)
print(np.round(FPBW/1e+6,2),'MHz')